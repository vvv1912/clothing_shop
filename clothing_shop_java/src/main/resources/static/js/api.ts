//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    toggleLockAccount(userId: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/{userId}/toggle-lock-account";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleLockAccount(_response);
        });
    }

    protected processToggleLockAccount(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    toggleRole(body: ToggleRoleToAccountCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/toggle-role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleRole(_response);
        });
    }

    protected processToggleRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateSupplier(id: number, body: UpdateSupplierCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/supplier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSupplier(_response);
        });
    }

    protected processUpdateSupplier(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    deleteSupplier(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/supplier/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteSupplier(_response);
        });
    }

    protected processDeleteSupplier(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getAllRoles( cancelToken?: CancelToken | undefined): Promise<RoleDto[]> {
        let url_ = this.baseUrl + "/api/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: AxiosResponse): Promise<RoleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<RoleDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto[]>(null as any);
    }

    /**
     * @return OK
     */
    updateRole(body: UpdateRoleCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createRole(body: CreateRoleCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param productId (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllRatingOfProduct(productId: number | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedRatingDto> {
        let url_ = this.baseUrl + "/api/rating?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRatingOfProduct(_response);
        });
    }

    protected processGetAllRatingOfProduct(response: AxiosResponse): Promise<PaginatedRatingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedRatingDto.fromJS(resultData200);
            return Promise.resolve<PaginatedRatingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedRatingDto>(null as any);
    }

    /**
     * @return OK
     */
    updateRating(body: UpdateRatingCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRating(_response);
        });
    }

    protected processUpdateRating(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createRating(body: CreateRatingCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/rating";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRating(_response);
        });
    }

    protected processCreateRating(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param fromDateTimestamp (optional) 
     * @param toDateTimestamp (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllPromotions(fromDateTimestamp: number | undefined, toDateTimestamp: number | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedPromotionDto> {
        let url_ = this.baseUrl + "/api/promotion?";
        if (fromDateTimestamp === null)
            throw new Error("The parameter 'fromDateTimestamp' cannot be null.");
        else if (fromDateTimestamp !== undefined)
            url_ += "fromDateTimestamp=" + encodeURIComponent("" + fromDateTimestamp) + "&";
        if (toDateTimestamp === null)
            throw new Error("The parameter 'toDateTimestamp' cannot be null.");
        else if (toDateTimestamp !== undefined)
            url_ += "toDateTimestamp=" + encodeURIComponent("" + toDateTimestamp) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPromotions(_response);
        });
    }

    protected processGetAllPromotions(response: AxiosResponse): Promise<PaginatedPromotionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedPromotionDto.fromJS(resultData200);
            return Promise.resolve<PaginatedPromotionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedPromotionDto>(null as any);
    }

    /**
     * @return OK
     */
    updatePromotion(body: UpdatePromotionCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/promotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePromotion(_response);
        });
    }

    protected processUpdatePromotion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createPromotion(body: CreatePromotionCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/promotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePromotion(_response);
        });
    }

    protected processCreatePromotion(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    updateProduct(body: UpdateProductCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createCategory(body: UpdateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    updateCartItemQuantity(body: UpdateCartItemQuantityCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/update-item-quantity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCartItemQuantity(_response);
        });
    }

    protected processUpdateCartItemQuantity(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    ipn(param: MomoCallbackParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/momo/ipn?";
        if (param === undefined || param === null)
            throw new Error("The parameter 'param' must be defined and cannot be null.");
        else
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIpn(_response);
        });
    }

    protected processIpn(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateMyPassword(body: UpdatePasswordCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/update-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyPassword(_response);
        });
    }

    protected processUpdateMyPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMyAvatar(body: Body | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/user/update-avatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyAvatar(_response);
        });
    }

    protected processUpdateMyAvatar(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getMyProfile( cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyProfile(_response);
        });
    }

    protected processGetMyProfile(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return OK
     */
    updateMyProfile(body: UpdateProfileCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyProfile(_response);
        });
    }

    protected processUpdateMyProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllSuppliers(page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedSupplierDto> {
        let url_ = this.baseUrl + "/api/supplier?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSuppliers(_response);
        });
    }

    protected processGetAllSuppliers(response: AxiosResponse): Promise<PaginatedSupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedSupplierDto.fromJS(resultData200);
            return Promise.resolve<PaginatedSupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedSupplierDto>(null as any);
    }

    /**
     * @return Created
     */
    createSupplier(body: CreateSupplierCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSupplier(_response);
        });
    }

    protected processCreateSupplier(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return Promise.resolve<number>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param supplierId (optional) 
     * @param totalFrom (optional) 
     * @param totalTo (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllStockReceipts(startDate: number | undefined, endDate: number | undefined, supplierId: number | undefined, totalFrom: number | undefined, totalTo: number | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedStockReceiptBriefDto> {
        let url_ = this.baseUrl + "/api/stock-receipt/?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (supplierId === null)
            throw new Error("The parameter 'supplierId' cannot be null.");
        else if (supplierId !== undefined)
            url_ += "supplierId=" + encodeURIComponent("" + supplierId) + "&";
        if (totalFrom === null)
            throw new Error("The parameter 'totalFrom' cannot be null.");
        else if (totalFrom !== undefined)
            url_ += "totalFrom=" + encodeURIComponent("" + totalFrom) + "&";
        if (totalTo === null)
            throw new Error("The parameter 'totalTo' cannot be null.");
        else if (totalTo !== undefined)
            url_ += "totalTo=" + encodeURIComponent("" + totalTo) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllStockReceipts(_response);
        });
    }

    protected processGetAllStockReceipts(response: AxiosResponse): Promise<PaginatedStockReceiptBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedStockReceiptBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedStockReceiptBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedStockReceiptBriefDto>(null as any);
    }

    /**
     * @return Created
     */
    createStockReceipt(body: CreateStockReceiptCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/stock-receipt/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateStockReceipt(_response);
        });
    }

    protected processCreateStockReceipt(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return Promise.resolve<number>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    updateShopSetting(body: UpdateShopInfoCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/shop-setting/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateShopSetting(_response);
        });
    }

    protected processUpdateShopSetting(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createProduct(body: CreateProductCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createProductOption(body: CreateProductOptionCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/product-option/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProductOption(_response);
        });
    }

    protected processCreateProductOption(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createProductOptionIfNotExist(body: CreateAndGetProductOptionCommand, cancelToken?: CancelToken | undefined): Promise<ProductOptionDetailDto> {
        let url_ = this.baseUrl + "/api/product-option/createIfNotExist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProductOptionIfNotExist(_response);
        });
    }

    protected processCreateProductOptionIfNotExist(response: AxiosResponse): Promise<ProductOptionDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductOptionDetailDto.fromJS(resultData200);
            return Promise.resolve<ProductOptionDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductOptionDetailDto>(null as any);
    }

    /**
     * @return OK
     */
    createProductImage(body: CreateProductImageCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-image/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProductImage(_response);
        });
    }

    protected processCreateProductImage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createPayment(body: CreatePaymentCommand, cancelToken?: CancelToken | undefined): Promise<CreatePaymentResponse> {
        let url_ = this.baseUrl + "/api/payment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePayment(_response);
        });
    }

    protected processCreatePayment(response: AxiosResponse): Promise<CreatePaymentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatePaymentResponse.fromJS(resultData200);
            return Promise.resolve<CreatePaymentResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreatePaymentResponse>(null as any);
    }

    /**
     * @return OK
     */
    createOrder(body: CreateOrderCommand, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/order/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    uploadFiles(files: FileParameter[], cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/file/uploads?";
        if (files === undefined || files === null)
            throw new Error("The parameter 'files' must be defined and cannot be null.");
        else
            files && files.forEach(item => { url_ += "files=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFiles(_response);
        });
    }

    protected processUploadFiles(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadFile(body: Body2 | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getDeliveryOption(body: GetDeliveryOptionQuery, cancelToken?: CancelToken | undefined): Promise<GetValidShipServiceResponse[]> {
        let url_ = this.baseUrl + "/api/delivery/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryOption(_response);
        });
    }

    protected processGetDeliveryOption(response: AxiosResponse): Promise<GetValidShipServiceResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetValidShipServiceResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetValidShipServiceResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetValidShipServiceResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    getDeliveryFee(body: GetDeliveryFeeQuery, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/delivery/fee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryFee(_response);
        });
    }

    protected processGetDeliveryFee(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createColor(body: CreateColorCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/color/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateColor(_response);
        });
    }

    protected processCreateColor(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    addToCart(body: AddToCartCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/add-to-cart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddToCart(_response);
        });
    }

    protected processAddToCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    removePermissionFromRole(body: RemovePermissionFromRoleCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/role/remove-permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemovePermissionFromRole(_response);
        });
    }

    protected processRemovePermissionFromRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    assignPermission(body: AddPermissionToRoleCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/role/assign-permission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAssignPermission(_response);
        });
    }

    protected processAssignPermission(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    toggleDisablePromotion(promotionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/promotion/{promotionId}/toggleDisable";
        if (promotionId === undefined || promotionId === null)
            throw new Error("The parameter 'promotionId' must be defined.");
        url_ = url_.replace("{promotionId}", encodeURIComponent("" + promotionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToggleDisablePromotion(_response);
        });
    }

    protected processToggleDisablePromotion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    recoveryProduct(productId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product/recovery/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecoveryProduct(_response);
        });
    }

    protected processRecoveryProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    recoveryProductOption(productOptionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-option/recovery/{productOptionId}";
        if (productOptionId === undefined || productOptionId === null)
            throw new Error("The parameter 'productOptionId' must be defined.");
        url_ = url_.replace("{productOptionId}", encodeURIComponent("" + productOptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRecoveryProductOption(_response);
        });
    }

    protected processRecoveryProductOption(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updatePaymentStatus(body: UpdatePaymentStatusCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/payment/update-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePaymentStatus(_response);
        });
    }

    protected processUpdatePaymentStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateOrderStatus(body: UpdateOrderStatusCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/updateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrderStatus(_response);
        });
    }

    protected processUpdateOrderStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    cancelOrder(body: CancelOrderCommand, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/order/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancelOrder(_response);
        });
    }

    protected processCancelOrder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accountType (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getUsers(accountType: string | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedUserDto> {
        let url_ = this.baseUrl + "/api/user?";
        if (accountType === null)
            throw new Error("The parameter 'accountType' cannot be null.");
        else if (accountType !== undefined)
            url_ += "accountType=" + encodeURIComponent("" + accountType) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<PaginatedUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedUserDto.fromJS(resultData200);
            return Promise.resolve<PaginatedUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedUserDto>(null as any);
    }

    /**
     * @return OK
     */
    getStockReceiptById(id: number, cancelToken?: CancelToken | undefined): Promise<StockReceiptDetailDto> {
        let url_ = this.baseUrl + "/api/stock-receipt/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStockReceiptById(_response);
        });
    }

    protected processGetStockReceiptById(response: AxiosResponse): Promise<StockReceiptDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StockReceiptDetailDto.fromJS(resultData200);
            return Promise.resolve<StockReceiptDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StockReceiptDetailDto>(null as any);
    }

    /**
     * @return No Content
     */
    deleteStockReceipt(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stock-receipt/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteStockReceipt(_response);
        });
    }

    protected processDeleteStockReceipt(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDateTimestamp (optional) 
     * @param endDateTimeStamp (optional) 
     * @return OK
     */
    getTopSoldProductReport(startDateTimestamp: number | undefined, endDateTimeStamp: number | undefined, cancelToken?: CancelToken | undefined): Promise<ProductReportDto[]> {
        let url_ = this.baseUrl + "/api/report/top-sold?";
        if (startDateTimestamp === null)
            throw new Error("The parameter 'startDateTimestamp' cannot be null.");
        else if (startDateTimestamp !== undefined)
            url_ += "startDateTimestamp=" + encodeURIComponent("" + startDateTimestamp) + "&";
        if (endDateTimeStamp === null)
            throw new Error("The parameter 'endDateTimeStamp' cannot be null.");
        else if (endDateTimeStamp !== undefined)
            url_ += "endDateTimeStamp=" + encodeURIComponent("" + endDateTimeStamp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetTopSoldProductReport(_response);
        });
    }

    protected processGetTopSoldProductReport(response: AxiosResponse): Promise<ProductReportDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ProductReportDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductReportDto[]>(null as any);
    }

    /**
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @return OK
     */
    getSoldReport(startDateTime: number | undefined, endDateTime: number | undefined, cancelToken?: CancelToken | undefined): Promise<SoldReportDto[]> {
        let url_ = this.baseUrl + "/api/report/sold?";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSoldReport(_response);
        });
    }

    protected processGetSoldReport(response: AxiosResponse): Promise<SoldReportDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SoldReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SoldReportDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SoldReportDto[]>(null as any);
    }

    /**
     * @param startDateTime (optional) 
     * @param endDateTime (optional) 
     * @return OK
     */
    getImportReport(startDateTime: number | undefined, endDateTime: number | undefined, cancelToken?: CancelToken | undefined): Promise<ImportProductReportDto[]> {
        let url_ = this.baseUrl + "/api/report/import?";
        if (startDateTime === null)
            throw new Error("The parameter 'startDateTime' cannot be null.");
        else if (startDateTime !== undefined)
            url_ += "startDateTime=" + encodeURIComponent("" + startDateTime) + "&";
        if (endDateTime === null)
            throw new Error("The parameter 'endDateTime' cannot be null.");
        else if (endDateTime !== undefined)
            url_ += "endDateTime=" + encodeURIComponent("" + endDateTime) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetImportReport(_response);
        });
    }

    protected processGetImportReport(response: AxiosResponse): Promise<ImportProductReportDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImportProductReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ImportProductReportDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ImportProductReportDto[]>(null as any);
    }

    /**
     * @param startDateTimestamp (optional) 
     * @param endDateTimeStamp (optional) 
     * @return OK
     */
    getCategoryReport(startDateTimestamp: number | undefined, endDateTimeStamp: number | undefined, cancelToken?: CancelToken | undefined): Promise<CategoryReportDto[]> {
        let url_ = this.baseUrl + "/api/report/category?";
        if (startDateTimestamp === null)
            throw new Error("The parameter 'startDateTimestamp' cannot be null.");
        else if (startDateTimestamp !== undefined)
            url_ += "startDateTimestamp=" + encodeURIComponent("" + startDateTimestamp) + "&";
        if (endDateTimeStamp === null)
            throw new Error("The parameter 'endDateTimeStamp' cannot be null.");
        else if (endDateTimeStamp !== undefined)
            url_ += "endDateTimeStamp=" + encodeURIComponent("" + endDateTimeStamp) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategoryReport(_response);
        });
    }

    protected processGetCategoryReport(response: AxiosResponse): Promise<CategoryReportDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryReportDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CategoryReportDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryReportDto[]>(null as any);
    }

    /**
     * @param productOptionId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    getMyRatingOfProduct(orderId: string, productOptionId: number | undefined, userId: string | undefined, cancelToken?: CancelToken | undefined): Promise<RatingDto> {
        let url_ = this.baseUrl + "/api/rating/my-rating?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (productOptionId === null)
            throw new Error("The parameter 'productOptionId' cannot be null.");
        else if (productOptionId !== undefined)
            url_ += "productOptionId=" + encodeURIComponent("" + productOptionId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyRatingOfProduct(_response);
        });
    }

    protected processGetMyRatingOfProduct(response: AxiosResponse): Promise<RatingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RatingDto.fromJS(resultData200);
            return Promise.resolve<RatingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RatingDto>(null as any);
    }

    /**
     * @param code (optional) 
     * @param orderValue (optional) 
     * @return OK
     */
    checkPromotion(code: string | undefined, orderValue: number | undefined, cancelToken?: CancelToken | undefined): Promise<PromotionDto> {
        let url_ = this.baseUrl + "/api/promotion/check?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (orderValue === null)
            throw new Error("The parameter 'orderValue' cannot be null.");
        else if (orderValue !== undefined)
            url_ += "orderValue=" + encodeURIComponent("" + orderValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPromotion(_response);
        });
    }

    protected processCheckPromotion(response: AxiosResponse): Promise<PromotionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PromotionDto.fromJS(resultData200);
            return Promise.resolve<PromotionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PromotionDto>(null as any);
    }

    /**
     * @return OK
     */
    getProductById(productId: number, cancelToken?: CancelToken | undefined): Promise<ProductDetailDto> {
        let url_ = this.baseUrl + "/api/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: AxiosResponse): Promise<ProductDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDetailDto.fromJS(resultData200);
            return Promise.resolve<ProductDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDetailDto>(null as any);
    }

    /**
     * @param categoryIds (optional) 
     * @param forGenders (optional) 
     * @param minPrice (optional) 
     * @param maxPrice (optional) 
     * @param colorIds (optional) 
     * @param sizes (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    searchProducts(categoryIds: number[] | undefined, forGenders: ForGenders[] | undefined, minPrice: number | undefined, maxPrice: number | undefined, colorIds: number[] | undefined, sizes: string[] | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedProductBriefDto> {
        let url_ = this.baseUrl + "/api/product/search?";
        if (categoryIds === null)
            throw new Error("The parameter 'categoryIds' cannot be null.");
        else if (categoryIds !== undefined)
            categoryIds && categoryIds.forEach(item => { url_ += "categoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (forGenders === null)
            throw new Error("The parameter 'forGenders' cannot be null.");
        else if (forGenders !== undefined)
            forGenders && forGenders.forEach(item => { url_ += "forGenders=" + encodeURIComponent("" + item) + "&"; });
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (colorIds === null)
            throw new Error("The parameter 'colorIds' cannot be null.");
        else if (colorIds !== undefined)
            colorIds && colorIds.forEach(item => { url_ += "colorIds=" + encodeURIComponent("" + item) + "&"; });
        if (sizes === null)
            throw new Error("The parameter 'sizes' cannot be null.");
        else if (sizes !== undefined)
            sizes && sizes.forEach(item => { url_ += "sizes=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: AxiosResponse): Promise<PaginatedProductBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedProductBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedProductBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedProductBriefDto>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param forGender (optional) 
     * @param minPrice (optional) 
     * @param maxPrice (optional) 
     * @param includeDeleted (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getProducts(categoryId: number | undefined, forGender: ForGender | undefined, minPrice: number | undefined, maxPrice: number | undefined, includeDeleted: boolean | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedProductBriefDto> {
        let url_ = this.baseUrl + "/api/product/?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (forGender === null)
            throw new Error("The parameter 'forGender' cannot be null.");
        else if (forGender !== undefined)
            url_ += "forGender=" + encodeURIComponent("" + forGender) + "&";
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: AxiosResponse): Promise<PaginatedProductBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedProductBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedProductBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedProductBriefDto>(null as any);
    }

    /**
     * @return OK
     */
    getAllSizes( cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/product-option/sizes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSizes(_response);
        });
    }

    protected processGetAllSizes(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return OK
     */
    getAllPermissions( cancelToken?: CancelToken | undefined): Promise<PermissionDto[]> {
        let url_ = this.baseUrl + "/api/permission";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<PermissionDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PermissionDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionDto[]>(null as any);
    }

    /**
     * @param statuses (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllPayment(statuses: Statuses[] | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedPaymentDto> {
        let url_ = this.baseUrl + "/api/payment?";
        if (statuses === null)
            throw new Error("The parameter 'statuses' cannot be null.");
        else if (statuses !== undefined)
            statuses && statuses.forEach(item => { url_ += "statuses=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPayment(_response);
        });
    }

    protected processGetAllPayment(response: AxiosResponse): Promise<PaginatedPaymentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedPaymentDto.fromJS(resultData200);
            return Promise.resolve<PaginatedPaymentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedPaymentDto>(null as any);
    }

    /**
     * @param paymentStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param orderStatus (optional) 
     * @param amountFrom (optional) 
     * @param amountTo (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllOrders(paymentStatus: PaymentStatus | undefined, startDate: number | undefined, endDate: number | undefined, orderStatus: OrderStatus | undefined, amountFrom: number | undefined, amountTo: number | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedOrderBriefDto> {
        let url_ = this.baseUrl + "/api/order?";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "paymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&";
        if (amountFrom === null)
            throw new Error("The parameter 'amountFrom' cannot be null.");
        else if (amountFrom !== undefined)
            url_ += "amountFrom=" + encodeURIComponent("" + amountFrom) + "&";
        if (amountTo === null)
            throw new Error("The parameter 'amountTo' cannot be null.");
        else if (amountTo !== undefined)
            url_ += "amountTo=" + encodeURIComponent("" + amountTo) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllOrders(_response);
        });
    }

    protected processGetAllOrders(response: AxiosResponse): Promise<PaginatedOrderBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedOrderBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedOrderBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedOrderBriefDto>(null as any);
    }

    /**
     * @return OK
     */
    getAllColors( cancelToken?: CancelToken | undefined): Promise<ColorDto[]> {
        let url_ = this.baseUrl + "/api/color";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllColors(_response);
        });
    }

    protected processGetAllColors(response: AxiosResponse): Promise<ColorDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ColorDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ColorDto[]>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getCategories(page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedCategoryBriefDto> {
        let url_ = this.baseUrl + "/api/category?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<PaginatedCategoryBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedCategoryBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedCategoryBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedCategoryBriefDto>(null as any);
    }

    /**
     * @return OK
     */
    getAllCategoriesGroupByParent( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/category/getAllCategoriesGroupByParent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllCategoriesGroupByParent(_response);
        });
    }

    protected processGetAllCategoriesGroupByParent(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMyCart( cancelToken?: CancelToken | undefined): Promise<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/cart/my-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyCart(_response);
        });
    }

    protected processGetMyCart(response: AxiosResponse): Promise<CartItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CartItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CartItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CartItemDto[]>(null as any);
    }

    /**
     * @return No Content
     */
    deleteRole(roleName: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/role/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    tryDeletePromotion(promotionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/promotion/{promotionId}";
        if (promotionId === undefined || promotionId === null)
            throw new Error("The parameter 'promotionId' must be defined.");
        url_ = url_.replace("{promotionId}", encodeURIComponent("" + promotionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTryDeletePromotion(_response);
        });
    }

    protected processTryDeletePromotion(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    deleteProduct(productId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product/delete/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    deleteProductOption(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProductOption(_response);
        });
    }

    protected processDeleteProductOption(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteProductImage(body: DeleteProductImageCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-image/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProductImage(_response);
        });
    }

    protected processDeleteProductImage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/category/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    removeItemFromCart(productOptionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/{productOptionId}";
        if (productOptionId === undefined || productOptionId === null)
            throw new Error("The parameter 'productOptionId' must be defined.");
        url_ = url_.replace("{productOptionId}", encodeURIComponent("" + productOptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveItemFromCart(_response);
        });
    }

    protected processRemoveItemFromCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    clearCart( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/clear-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class CreateCategoryClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1(body: CreateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

class ToggleRoleToAccountCommand implements IToggleRoleToAccountCommand {
    userId?: string;
    roleId?: string;

    [key: string]: any;

    constructor(data?: IToggleRoleToAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): ToggleRoleToAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ToggleRoleToAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

interface IToggleRoleToAccountCommand {
    userId?: string;
    roleId?: string;

    [key: string]: any;
}

class UpdateSupplierCommand implements IUpdateSupplierCommand {
    supplierId?: number;
    name!: string;
    address!: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: IUpdateSupplierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.supplierId = _data["supplierId"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateSupplierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["supplierId"] = this.supplierId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["description"] = this.description;
        return data;
    }
}

interface IUpdateSupplierCommand {
    supplierId?: number;
    name: string;
    address: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;
}

class UpdateRoleCommand implements IUpdateRoleCommand {
    normalizedName!: string;
    displayName!: string;
    description!: string;

    [key: string]: any;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.normalizedName = _data["normalizedName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["normalizedName"] = this.normalizedName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

interface IUpdateRoleCommand {
    normalizedName: string;
    displayName: string;
    description: string;

    [key: string]: any;
}

class UpdateRatingCommand implements IUpdateRatingCommand {
    id?: number;
    content?: string;
    value?: number;

    [key: string]: any;

    constructor(data?: IUpdateRatingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.content = _data["content"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateRatingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRatingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["content"] = this.content;
        data["value"] = this.value;
        return data;
    }
}

interface IUpdateRatingCommand {
    id?: number;
    content?: string;
    value?: number;

    [key: string]: any;
}

class UpdatePromotionCommand implements IUpdatePromotionCommand {
    promotionId?: number;
    code!: string;
    name!: string;
    description?: string;
    discount?: number;
    type!: UpdatePromotionCommandType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate!: Date;
    endDate!: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;

    constructor(data?: IUpdatePromotionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.promotionId = _data["promotionId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discount = _data["discount"];
            this.type = _data["type"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.maxValue = _data["maxValue"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): UpdatePromotionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePromotionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["promotionId"] = this.promotionId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discount"] = this.discount;
        data["type"] = this.type;
        data["minOrderAmount"] = this.minOrderAmount;
        data["maxValue"] = this.maxValue;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        data["stock"] = this.stock;
        return data;
    }
}

interface IUpdatePromotionCommand {
    promotionId?: number;
    code: string;
    name: string;
    description?: string;
    discount?: number;
    type: UpdatePromotionCommandType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate: Date;
    endDate: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;
}

class UpdateProductCommand implements IUpdateProductCommand {
    productId!: number;
    name!: string;
    forGender?: UpdateProductCommandForGender;
    description!: string;
    price!: number;
    discount?: number;
    displayImage!: string;
    brandId?: number;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["description"] = this.description;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

interface IUpdateProductCommand {
    productId: number;
    name: string;
    forGender?: UpdateProductCommandForGender;
    description: string;
    price: number;
    discount?: number;
    displayImage: string;
    brandId?: number;
    categoryId: number;

    [key: string]: any;
}

class UpdateCategoryCommand implements IUpdateCategoryCommand {
    id!: number;
    name!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface IUpdateCategoryCommand {
    id: number;
    name: string;
    parentId?: number;

    [key: string]: any;
}

class UpdateCartItemQuantityCommand implements IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;

    constructor(data?: IUpdateCartItemQuantityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.newQuantity = _data["newQuantity"];
        }
    }

    static fromJS(data: any): UpdateCartItemQuantityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCartItemQuantityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["newQuantity"] = this.newQuantity;
        return data;
    }
}

interface IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;
}

class MomoCallbackParam implements IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;

    constructor(data?: IMomoCallbackParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.partnerCode = _data["partnerCode"];
            this.orderId = _data["orderId"];
            this.requestId = _data["requestId"];
            this.amount = _data["amount"];
            this.orderInfo = _data["orderInfo"];
            this.orderType = _data["orderType"];
            this.transId = _data["transId"];
            this.resultCode = _data["resultCode"];
            this.message = _data["message"];
            this.payType = _data["payType"];
            this.responseTime = _data["responseTime"];
            this.extraData = _data["extraData"];
            this.signature = _data["signature"];
        }
    }

    static fromJS(data: any): MomoCallbackParam {
        data = typeof data === 'object' ? data : {};
        let result = new MomoCallbackParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["partnerCode"] = this.partnerCode;
        data["orderId"] = this.orderId;
        data["requestId"] = this.requestId;
        data["amount"] = this.amount;
        data["orderInfo"] = this.orderInfo;
        data["orderType"] = this.orderType;
        data["transId"] = this.transId;
        data["resultCode"] = this.resultCode;
        data["message"] = this.message;
        data["payType"] = this.payType;
        data["responseTime"] = this.responseTime;
        data["extraData"] = this.extraData;
        data["signature"] = this.signature;
        return data;
    }
}

interface IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;
}

class UpdatePasswordCommand implements IUpdatePasswordCommand {
    oldPassword!: string;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

interface IUpdatePasswordCommand {
    oldPassword: string;
    newPassword?: string;

    [key: string]: any;
}

class UpdateProfileCommand implements IUpdateProfileCommand {
    firstName!: string;
    lastName!: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

interface IUpdateProfileCommand {
    firstName: string;
    lastName: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;
}

class CreateSupplierCommand implements ICreateSupplierCommand {
    name!: string;
    address!: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: ICreateSupplierCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateSupplierCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["description"] = this.description;
        return data;
    }
}

interface ICreateSupplierCommand {
    name: string;
    address: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;
}

class CreateItemCommand implements ICreateItemCommand {
    productOptionId?: number;
    quantity?: number;
    price?: number;

    [key: string]: any;

    constructor(data?: ICreateItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): CreateItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        return data;
    }
}

interface ICreateItemCommand {
    productOptionId?: number;
    quantity?: number;
    price?: number;

    [key: string]: any;
}

class CreateStockReceiptCommand implements ICreateStockReceiptCommand {
    note?: string;
    supplierId?: number;
    stockReceiptItems?: CreateItemCommand[];

    [key: string]: any;

    constructor(data?: ICreateStockReceiptCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.note = _data["note"];
            this.supplierId = _data["supplierId"];
            if (Array.isArray(_data["stockReceiptItems"])) {
                this.stockReceiptItems = [] as any;
                for (let item of _data["stockReceiptItems"])
                    this.stockReceiptItems!.push(CreateItemCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateStockReceiptCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStockReceiptCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["note"] = this.note;
        data["supplierId"] = this.supplierId;
        if (Array.isArray(this.stockReceiptItems)) {
            data["stockReceiptItems"] = [];
            for (let item of this.stockReceiptItems)
                data["stockReceiptItems"].push(item.toJSON());
        }
        return data;
    }
}

interface ICreateStockReceiptCommand {
    note?: string;
    supplierId?: number;
    stockReceiptItems?: CreateItemCommand[];

    [key: string]: any;
}

class UpdateShopInfoCommand implements IUpdateShopInfoCommand {
    shopName!: string;
    shopPhone?: string;
    shopEmail?: string;
    shopCity!: string;
    shopWard!: string;
    shopDistrict!: string;
    shopStreet!: string;
    shopOwner!: string;
    shopLogo?: string;

    [key: string]: any;

    constructor(data?: IUpdateShopInfoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.shopName = _data["shopName"];
            this.shopPhone = _data["shopPhone"];
            this.shopEmail = _data["shopEmail"];
            this.shopCity = _data["shopCity"];
            this.shopWard = _data["shopWard"];
            this.shopDistrict = _data["shopDistrict"];
            this.shopStreet = _data["shopStreet"];
            this.shopOwner = _data["shopOwner"];
            this.shopLogo = _data["shopLogo"];
        }
    }

    static fromJS(data: any): UpdateShopInfoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopInfoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["shopName"] = this.shopName;
        data["shopPhone"] = this.shopPhone;
        data["shopEmail"] = this.shopEmail;
        data["shopCity"] = this.shopCity;
        data["shopWard"] = this.shopWard;
        data["shopDistrict"] = this.shopDistrict;
        data["shopStreet"] = this.shopStreet;
        data["shopOwner"] = this.shopOwner;
        data["shopLogo"] = this.shopLogo;
        return data;
    }
}

interface IUpdateShopInfoCommand {
    shopName: string;
    shopPhone?: string;
    shopEmail?: string;
    shopCity: string;
    shopWard: string;
    shopDistrict: string;
    shopStreet: string;
    shopOwner: string;
    shopLogo?: string;

    [key: string]: any;
}

class CreateRoleCommand implements ICreateRoleCommand {
    normalizedName?: string;
    displayName!: string;
    description!: string;

    [key: string]: any;

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.normalizedName = _data["normalizedName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["normalizedName"] = this.normalizedName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

interface ICreateRoleCommand {
    normalizedName?: string;
    displayName: string;
    description: string;

    [key: string]: any;
}

class CreateRatingCommand implements ICreateRatingCommand {
    content?: string;
    value?: number;
    productOptionId?: number;
    orderId?: string;

    [key: string]: any;

    constructor(data?: ICreateRatingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.content = _data["content"];
            this.value = _data["value"];
            this.productOptionId = _data["productOptionId"];
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreateRatingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRatingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["content"] = this.content;
        data["value"] = this.value;
        data["productOptionId"] = this.productOptionId;
        data["orderId"] = this.orderId;
        return data;
    }
}

interface ICreateRatingCommand {
    content?: string;
    value?: number;
    productOptionId?: number;
    orderId?: string;

    [key: string]: any;
}

class CreatePromotionCommand implements ICreatePromotionCommand {
    code!: string;
    name!: string;
    description?: string;
    discount?: number;
    type!: CreatePromotionCommandType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate!: Date;
    endDate!: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;

    constructor(data?: ICreatePromotionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discount = _data["discount"];
            this.type = _data["type"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.maxValue = _data["maxValue"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): CreatePromotionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePromotionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discount"] = this.discount;
        data["type"] = this.type;
        data["minOrderAmount"] = this.minOrderAmount;
        data["maxValue"] = this.maxValue;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        data["stock"] = this.stock;
        return data;
    }
}

interface ICreatePromotionCommand {
    code: string;
    name: string;
    description?: string;
    discount?: number;
    type: CreatePromotionCommandType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate: Date;
    endDate: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;
}

class CreateProductCommand implements ICreateProductCommand {
    name!: string;
    forGender?: CreateProductCommandForGender;
    description!: string;
    price!: number;
    discount?: number;
    displayImage!: string;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["description"] = this.description;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

interface ICreateProductCommand {
    name: string;
    forGender?: CreateProductCommandForGender;
    description: string;
    price: number;
    discount?: number;
    displayImage: string;
    categoryId: number;

    [key: string]: any;
}

class CreateProductOptionCommand implements ICreateProductOptionCommand {
    colorName!: string;
    size!: string;
    stock?: number;
    productId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorName = _data["colorName"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorName"] = this.colorName;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["productId"] = this.productId;
        return data;
    }
}

interface ICreateProductOptionCommand {
    colorName: string;
    size: string;
    stock?: number;
    productId: number;

    [key: string]: any;
}

class CreateAndGetProductOptionCommand implements ICreateAndGetProductOptionCommand {
    colorName!: string;
    size!: string;
    stock?: number;
    productId!: number;

    [key: string]: any;

    constructor(data?: ICreateAndGetProductOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorName = _data["colorName"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateAndGetProductOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAndGetProductOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorName"] = this.colorName;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["productId"] = this.productId;
        return data;
    }
}

interface ICreateAndGetProductOptionCommand {
    colorName: string;
    size: string;
    stock?: number;
    productId: number;

    [key: string]: any;
}

class CategoryBriefDto implements ICategoryBriefDto {
    createdDate?: Date;
    categoryId?: number;
    name?: string;
    parent?: CategoryBriefDto;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: ICategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.parent = _data["parent"] ? CategoryBriefDto.fromJS(_data["parent"]) : <any>undefined;
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): CategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface ICategoryBriefDto {
    createdDate?: Date;
    categoryId?: number;
    name?: string;
    parent?: CategoryBriefDto;
    createdDateDisplay?: string;

    [key: string]: any;
}

class ColorDto implements IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;

    constructor(data?: IColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorId = _data["colorId"];
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): ColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorId"] = this.colorId;
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;
}

class ProductBriefDto implements IProductBriefDto {
    createdDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    totalSold?: number;
    averageRating?: number;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;
    averageRatingDisplay?: number;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.totalSold = _data["totalSold"];
            this.averageRating = _data["averageRating"];
            this.finalPrice = _data["finalPrice"];
            this.vietnamesePrice = _data["vietnamesePrice"];
            this.forGenderDisplay = _data["forGenderDisplay"];
            this.averageRatingDisplay = _data["averageRatingDisplay"];
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): ProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["totalSold"] = this.totalSold;
        data["averageRating"] = this.averageRating;
        data["finalPrice"] = this.finalPrice;
        data["vietnamesePrice"] = this.vietnamesePrice;
        data["forGenderDisplay"] = this.forGenderDisplay;
        data["averageRatingDisplay"] = this.averageRatingDisplay;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IProductBriefDto {
    createdDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    totalSold?: number;
    averageRating?: number;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;
    averageRatingDisplay?: number;
    createdDateDisplay?: string;

    [key: string]: any;
}

class ProductOptionDetailDto implements IProductOptionDetailDto {
    createdDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;
    quantity?: number;
    finalPrice?: number;
    finalPriceDisplay?: string;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductOptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
            this.product = _data["product"] ? ProductBriefDto.fromJS(_data["product"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.finalPrice = _data["finalPrice"];
            this.finalPriceDisplay = _data["finalPriceDisplay"];
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): ProductOptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["finalPrice"] = this.finalPrice;
        data["finalPriceDisplay"] = this.finalPriceDisplay;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IProductOptionDetailDto {
    createdDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;
    quantity?: number;
    finalPrice?: number;
    finalPriceDisplay?: string;
    createdDateDisplay?: string;

    [key: string]: any;
}

class CreateProductImageCommand implements ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.colorId = _data["colorId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["colorId"] = this.colorId;
        data["url"] = this.url;
        return data;
    }
}

interface ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;
}

class CreatePaymentCommand implements ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;

    constructor(data?: ICreatePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreatePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderId"] = this.orderId;
        return data;
    }
}

interface ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;
}

class CreatePaymentResponse implements ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;

    constructor(data?: ICreatePaymentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.paymentMethod = _data["paymentMethod"];
            this.orderId = _data["orderId"];
            this.redirectUrl = _data["redirectUrl"];
            this.mobileUrl = _data["mobileUrl"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): CreatePaymentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["paymentMethod"] = this.paymentMethod;
        data["orderId"] = this.orderId;
        data["redirectUrl"] = this.redirectUrl;
        data["mobileUrl"] = this.mobileUrl;
        data["redirect"] = this.redirect;
        return data;
    }
}

interface ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;
}

class CreateOrderCommand implements ICreateOrderCommand {
    orderItems!: OrderItem[];
    customerName!: string;
    address!: string;
    phoneNumber!: string;
    email!: string;
    note?: string;
    promotionCode?: string;
    paymentMethod!: CreateOrderCommandPaymentMethod;
    shipServiceId?: string;

    [key: string]: any;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.orderItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItem.fromJS(item));
            }
            this.customerName = _data["customerName"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.promotionCode = _data["promotionCode"];
            this.paymentMethod = _data["paymentMethod"];
            this.shipServiceId = _data["shipServiceId"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["customerName"] = this.customerName;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["promotionCode"] = this.promotionCode;
        data["paymentMethod"] = this.paymentMethod;
        data["shipServiceId"] = this.shipServiceId;
        return data;
    }
}

interface ICreateOrderCommand {
    orderItems: OrderItem[];
    customerName: string;
    address: string;
    phoneNumber: string;
    email: string;
    note?: string;
    promotionCode?: string;
    paymentMethod: CreateOrderCommandPaymentMethod;
    shipServiceId?: string;

    [key: string]: any;
}

class OrderItem implements IOrderItem {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        return data;
    }
}

interface IOrderItem {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;
}

class GetDeliveryOptionQuery implements IGetDeliveryOptionQuery {
    toAddress?: string;
    orderValue?: number;
    cod?: number;
    widthInCm?: number;
    heightInCm?: number;
    lengthInCm?: number;
    weightInGram?: number;
    toDistrict?: string;
    toProvince?: string;
    toWard?: string;
    toDetailAddress?: string;

    [key: string]: any;

    constructor(data?: IGetDeliveryOptionQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.toAddress = _data["toAddress"];
            this.orderValue = _data["orderValue"];
            this.cod = _data["cod"];
            this.widthInCm = _data["widthInCm"];
            this.heightInCm = _data["heightInCm"];
            this.lengthInCm = _data["lengthInCm"];
            this.weightInGram = _data["weightInGram"];
            this.toDistrict = _data["toDistrict"];
            this.toProvince = _data["toProvince"];
            this.toWard = _data["toWard"];
            this.toDetailAddress = _data["toDetailAddress"];
        }
    }

    static fromJS(data: any): GetDeliveryOptionQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeliveryOptionQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["toAddress"] = this.toAddress;
        data["orderValue"] = this.orderValue;
        data["cod"] = this.cod;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["lengthInCm"] = this.lengthInCm;
        data["weightInGram"] = this.weightInGram;
        data["toDistrict"] = this.toDistrict;
        data["toProvince"] = this.toProvince;
        data["toWard"] = this.toWard;
        data["toDetailAddress"] = this.toDetailAddress;
        return data;
    }
}

interface IGetDeliveryOptionQuery {
    toAddress?: string;
    orderValue?: number;
    cod?: number;
    widthInCm?: number;
    heightInCm?: number;
    lengthInCm?: number;
    weightInGram?: number;
    toDistrict?: string;
    toProvince?: string;
    toWard?: string;
    toDetailAddress?: string;

    [key: string]: any;
}

class GetValidShipServiceResponse implements IGetValidShipServiceResponse {
    id?: string;
    carrierName?: string;
    carrierLogo?: string;
    service?: string;
    expected?: string;
    totalFree?: number;
    totalAmount?: number;

    [key: string]: any;

    constructor(data?: IGetValidShipServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.carrierName = _data["carrierName"];
            this.carrierLogo = _data["carrierLogo"];
            this.service = _data["service"];
            this.expected = _data["expected"];
            this.totalFree = _data["totalFree"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): GetValidShipServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetValidShipServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["carrierName"] = this.carrierName;
        data["carrierLogo"] = this.carrierLogo;
        data["service"] = this.service;
        data["expected"] = this.expected;
        data["totalFree"] = this.totalFree;
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

interface IGetValidShipServiceResponse {
    id?: string;
    carrierName?: string;
    carrierLogo?: string;
    service?: string;
    expected?: string;
    totalFree?: number;
    totalAmount?: number;

    [key: string]: any;
}

class GetDeliveryFeeQuery implements IGetDeliveryFeeQuery {
    toProvince!: string;
    toDistrict!: string;
    toWard!: string;
    totalPrice?: number;

    [key: string]: any;

    constructor(data?: IGetDeliveryFeeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.toProvince = _data["toProvince"];
            this.toDistrict = _data["toDistrict"];
            this.toWard = _data["toWard"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): GetDeliveryFeeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeliveryFeeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["toProvince"] = this.toProvince;
        data["toDistrict"] = this.toDistrict;
        data["toWard"] = this.toWard;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

interface IGetDeliveryFeeQuery {
    toProvince: string;
    toDistrict: string;
    toWard: string;
    totalPrice?: number;

    [key: string]: any;
}

class CreateColorCommand implements ICreateColorCommand {
    name!: string;
    image?: string;

    [key: string]: any;

    constructor(data?: ICreateColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CreateColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface ICreateColorCommand {
    name: string;
    image?: string;

    [key: string]: any;
}

class CreateCategoryCommand implements ICreateCategoryCommand {
    name!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface ICreateCategoryCommand {
    name: string;
    parentId?: number;

    [key: string]: any;
}

class AddToCartCommand implements IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;

    constructor(data?: IAddToCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        return data;
    }
}

interface IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;
}

class RemovePermissionFromRoleCommand implements IRemovePermissionFromRoleCommand {
    roleName!: string;
    permissionName!: string;

    [key: string]: any;

    constructor(data?: IRemovePermissionFromRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.roleName = _data["roleName"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): RemovePermissionFromRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemovePermissionFromRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["roleName"] = this.roleName;
        data["permissionName"] = this.permissionName;
        return data;
    }
}

interface IRemovePermissionFromRoleCommand {
    roleName: string;
    permissionName: string;

    [key: string]: any;
}

class AddPermissionToRoleCommand implements IAddPermissionToRoleCommand {
    roleName!: string;
    permissionName!: string;

    [key: string]: any;

    constructor(data?: IAddPermissionToRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.roleName = _data["roleName"];
            this.permissionName = _data["permissionName"];
        }
    }

    static fromJS(data: any): AddPermissionToRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPermissionToRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["roleName"] = this.roleName;
        data["permissionName"] = this.permissionName;
        return data;
    }
}

interface IAddPermissionToRoleCommand {
    roleName: string;
    permissionName: string;

    [key: string]: any;
}

class UpdatePaymentStatusCommand implements IUpdatePaymentStatusCommand {
    paymentId?: string;
    status?: UpdatePaymentStatusCommandStatus;

    [key: string]: any;

    constructor(data?: IUpdatePaymentStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdatePaymentStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["status"] = this.status;
        return data;
    }
}

interface IUpdatePaymentStatusCommand {
    paymentId?: string;
    status?: UpdatePaymentStatusCommandStatus;

    [key: string]: any;
}

class UpdateOrderStatusCommand implements IUpdateOrderStatusCommand {
    orderId?: string;
    status?: UpdateOrderStatusCommandStatus;

    [key: string]: any;

    constructor(data?: IUpdateOrderStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderId = _data["orderId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateOrderStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        return data;
    }
}

interface IUpdateOrderStatusCommand {
    orderId?: string;
    status?: UpdateOrderStatusCommandStatus;

    [key: string]: any;
}

class CancelOrderCommand implements ICancelOrderCommand {
    orderId!: string;
    reason?: string;

    [key: string]: any;

    constructor(data?: ICancelOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderId = _data["orderId"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): CancelOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CancelOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderId"] = this.orderId;
        data["reason"] = this.reason;
        return data;
    }
}

interface ICancelOrderCommand {
    orderId: string;
    reason?: string;

    [key: string]: any;
}

class PaginatedUserDto implements IPaginatedUserDto {
    data?: UserDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedUserDto {
    data?: UserDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PermissionDto implements IPermissionDto {
    normalizedName?: string;
    displayName?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.normalizedName = _data["normalizedName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["normalizedName"] = this.normalizedName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

interface IPermissionDto {
    normalizedName?: string;
    displayName?: string;
    description?: string;

    [key: string]: any;
}

class RoleDto implements IRoleDto {
    normalizedName?: string;
    displayName?: string;
    description?: string;
    permissions?: PermissionDto[];

    [key: string]: any;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.normalizedName = _data["normalizedName"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["normalizedName"] = this.normalizedName;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

interface IRoleDto {
    normalizedName?: string;
    displayName?: string;
    description?: string;
    permissions?: PermissionDto[];

    [key: string]: any;
}

class UserDto implements IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    avatarUrl?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    createdAt?: Date;
    permissions?: string[];
    roles?: RoleDto[];
    accountEnabled?: boolean;
    customer?: boolean;
    emailVerified?: boolean;

    [key: string]: any;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.avatarUrl = _data["avatarUrl"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item));
            }
            this.accountEnabled = _data["accountEnabled"];
            this.customer = _data["customer"];
            this.emailVerified = _data["emailVerified"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["avatarUrl"] = this.avatarUrl;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["accountEnabled"] = this.accountEnabled;
        data["customer"] = this.customer;
        data["emailVerified"] = this.emailVerified;
        return data;
    }
}

interface IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    avatarUrl?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    createdAt?: Date;
    permissions?: string[];
    roles?: RoleDto[];
    accountEnabled?: boolean;
    customer?: boolean;
    emailVerified?: boolean;

    [key: string]: any;
}

class PaginatedSupplierDto implements IPaginatedSupplierDto {
    data?: SupplierDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SupplierDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedSupplierDto {
    data?: SupplierDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class SupplierDto implements ISupplierDto {
    supplierId?: number;
    name?: string;
    address?: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;

    constructor(data?: ISupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.supplierId = _data["supplierId"];
            this.name = _data["name"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["supplierId"] = this.supplierId;
        data["name"] = this.name;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["description"] = this.description;
        return data;
    }
}

interface ISupplierDto {
    supplierId?: number;
    name?: string;
    address?: string;
    phone?: string;
    email?: string;
    description?: string;

    [key: string]: any;
}

class StockReceiptDetailDto implements IStockReceiptDetailDto {
    createdDate?: Date;
    stockReceiptId?: number;
    total?: number;
    note?: string;
    supplierId?: number;
    supplier?: SupplierDto;
    stockReceiptItems?: StockReceiptItemDto[];
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IStockReceiptDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.stockReceiptId = _data["stockReceiptId"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierDto.fromJS(_data["supplier"]) : <any>undefined;
            if (Array.isArray(_data["stockReceiptItems"])) {
                this.stockReceiptItems = [] as any;
                for (let item of _data["stockReceiptItems"])
                    this.stockReceiptItems!.push(StockReceiptItemDto.fromJS(item));
            }
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): StockReceiptDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new StockReceiptDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["stockReceiptId"] = this.stockReceiptId;
        data["total"] = this.total;
        data["note"] = this.note;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        if (Array.isArray(this.stockReceiptItems)) {
            data["stockReceiptItems"] = [];
            for (let item of this.stockReceiptItems)
                data["stockReceiptItems"].push(item.toJSON());
        }
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IStockReceiptDetailDto {
    createdDate?: Date;
    stockReceiptId?: number;
    total?: number;
    note?: string;
    supplierId?: number;
    supplier?: SupplierDto;
    stockReceiptItems?: StockReceiptItemDto[];
    createdDateDisplay?: string;

    [key: string]: any;
}

class StockReceiptItemDto implements IStockReceiptItemDto {
    stockReceiptId?: number;
    productOptionId?: number;
    quantity?: number;
    price?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;

    constructor(data?: IStockReceiptItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.stockReceiptId = _data["stockReceiptId"];
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.productOption = _data["productOption"] ? ProductOptionDetailDto.fromJS(_data["productOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StockReceiptItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new StockReceiptItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["stockReceiptId"] = this.stockReceiptId;
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["productOption"] = this.productOption ? this.productOption.toJSON() : <any>undefined;
        return data;
    }
}

interface IStockReceiptItemDto {
    stockReceiptId?: number;
    productOptionId?: number;
    quantity?: number;
    price?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;
}

class PaginatedStockReceiptBriefDto implements IPaginatedStockReceiptBriefDto {
    data?: StockReceiptBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedStockReceiptBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StockReceiptBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedStockReceiptBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedStockReceiptBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedStockReceiptBriefDto {
    data?: StockReceiptBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class StockReceiptBriefDto implements IStockReceiptBriefDto {
    createdDate?: Date;
    stockReceiptId?: number;
    total?: number;
    note?: string;
    supplierId?: number;
    supplier?: SupplierDto;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IStockReceiptBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.stockReceiptId = _data["stockReceiptId"];
            this.total = _data["total"];
            this.note = _data["note"];
            this.supplierId = _data["supplierId"];
            this.supplier = _data["supplier"] ? SupplierDto.fromJS(_data["supplier"]) : <any>undefined;
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): StockReceiptBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new StockReceiptBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["stockReceiptId"] = this.stockReceiptId;
        data["total"] = this.total;
        data["note"] = this.note;
        data["supplierId"] = this.supplierId;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IStockReceiptBriefDto {
    createdDate?: Date;
    stockReceiptId?: number;
    total?: number;
    note?: string;
    supplierId?: number;
    supplier?: SupplierDto;
    createdDateDisplay?: string;

    [key: string]: any;
}

class ProductReportDto implements IProductReportDto {
    product?: ProductBriefDto;
    totalSold?: number;
    totalRevenue?: number;

    [key: string]: any;

    constructor(data?: IProductReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.product = _data["product"] ? ProductBriefDto.fromJS(_data["product"]) : <any>undefined;
            this.totalSold = _data["totalSold"];
            this.totalRevenue = _data["totalRevenue"];
        }
    }

    static fromJS(data: any): ProductReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["totalSold"] = this.totalSold;
        data["totalRevenue"] = this.totalRevenue;
        return data;
    }
}

interface IProductReportDto {
    product?: ProductBriefDto;
    totalSold?: number;
    totalRevenue?: number;

    [key: string]: any;
}

class SoldReportDto implements ISoldReportDto {
    date?: Date;
    totalOrder?: number;
    totalRevenue?: number;
    totalQuantitySold?: number;

    [key: string]: any;

    constructor(data?: ISoldReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.totalOrder = _data["totalOrder"];
            this.totalRevenue = _data["totalRevenue"];
            this.totalQuantitySold = _data["totalQuantitySold"];
        }
    }

    static fromJS(data: any): SoldReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoldReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalOrder"] = this.totalOrder;
        data["totalRevenue"] = this.totalRevenue;
        data["totalQuantitySold"] = this.totalQuantitySold;
        return data;
    }
}

interface ISoldReportDto {
    date?: Date;
    totalOrder?: number;
    totalRevenue?: number;
    totalQuantitySold?: number;

    [key: string]: any;
}

class ImportProductReportDto implements IImportProductReportDto {
    date?: Date;
    totalImport?: number;
    totalCost?: number;
    totalQuantityImport?: number;

    [key: string]: any;

    constructor(data?: IImportProductReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.totalImport = _data["totalImport"];
            this.totalCost = _data["totalCost"];
            this.totalQuantityImport = _data["totalQuantityImport"];
        }
    }

    static fromJS(data: any): ImportProductReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportProductReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["totalImport"] = this.totalImport;
        data["totalCost"] = this.totalCost;
        data["totalQuantityImport"] = this.totalQuantityImport;
        return data;
    }
}

interface IImportProductReportDto {
    date?: Date;
    totalImport?: number;
    totalCost?: number;
    totalQuantityImport?: number;

    [key: string]: any;
}

class CategoryReportDto implements ICategoryReportDto {
    category?: CategoryBriefDto;
    totalProducts?: number;
    totalSoldProducts?: number;
    totalRevenue?: number;

    [key: string]: any;

    constructor(data?: ICategoryReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.totalProducts = _data["totalProducts"];
            this.totalSoldProducts = _data["totalSoldProducts"];
            this.totalRevenue = _data["totalRevenue"];
        }
    }

    static fromJS(data: any): CategoryReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["totalProducts"] = this.totalProducts;
        data["totalSoldProducts"] = this.totalSoldProducts;
        data["totalRevenue"] = this.totalRevenue;
        return data;
    }
}

interface ICategoryReportDto {
    category?: CategoryBriefDto;
    totalProducts?: number;
    totalSoldProducts?: number;
    totalRevenue?: number;

    [key: string]: any;
}

class PaginatedRatingDto implements IPaginatedRatingDto {
    data?: RatingDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedRatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RatingDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedRatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedRatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedRatingDto {
    data?: RatingDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class ProductOptionDto implements IProductOptionDto {
    createdDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): ProductOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IProductOptionDto {
    createdDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    createdDateDisplay?: string;

    [key: string]: any;
}

class RatingDto implements IRatingDto {
    createdDate?: Date;
    id?: number;
    content?: string;
    value?: number;
    user?: UserBriefDto;
    productOption?: ProductOptionDto;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IRatingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.content = _data["content"];
            this.value = _data["value"];
            this.user = _data["user"] ? UserBriefDto.fromJS(_data["user"]) : <any>undefined;
            this.productOption = _data["productOption"] ? ProductOptionDto.fromJS(_data["productOption"]) : <any>undefined;
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): RatingDto {
        data = typeof data === 'object' ? data : {};
        let result = new RatingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["content"] = this.content;
        data["value"] = this.value;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["productOption"] = this.productOption ? this.productOption.toJSON() : <any>undefined;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IRatingDto {
    createdDate?: Date;
    id?: number;
    content?: string;
    value?: number;
    user?: UserBriefDto;
    productOption?: ProductOptionDto;
    createdDateDisplay?: string;

    [key: string]: any;
}

class UserBriefDto implements IUserBriefDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    avatarUrl?: string;

    [key: string]: any;

    constructor(data?: IUserBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): UserBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

interface IUserBriefDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    avatarUrl?: string;

    [key: string]: any;
}

class PaginatedPromotionDto implements IPaginatedPromotionDto {
    data?: PromotionDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PromotionDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedPromotionDto {
    data?: PromotionDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PromotionDto implements IPromotionDto {
    promotionId?: number;
    code?: string;
    name?: string;
    description?: string;
    discount?: number;
    type?: PromotionDtoType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate?: Date;
    endDate?: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;

    constructor(data?: IPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.promotionId = _data["promotionId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discount = _data["discount"];
            this.type = _data["type"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.maxValue = _data["maxValue"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): PromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["promotionId"] = this.promotionId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discount"] = this.discount;
        data["type"] = this.type;
        data["minOrderAmount"] = this.minOrderAmount;
        data["maxValue"] = this.maxValue;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        data["stock"] = this.stock;
        return data;
    }
}

interface IPromotionDto {
    promotionId?: number;
    code?: string;
    name?: string;
    description?: string;
    discount?: number;
    type?: PromotionDtoType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate?: Date;
    endDate?: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;
}

class ProductDetailDto implements IProductDetailDto {
    createdDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    totalSold?: number;
    averageRating?: number;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;
    averageRatingDisplay?: number;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.totalSold = _data["totalSold"];
            this.averageRating = _data["averageRating"];
            if (Array.isArray(_data["productOptions"])) {
                this.productOptions = [] as any;
                for (let item of _data["productOptions"])
                    this.productOptions!.push(ProductOptionDto.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            this.description = _data["description"];
            this.finalPrice = _data["finalPrice"];
            this.vietnamesePrice = _data["vietnamesePrice"];
            this.forGenderDisplay = _data["forGenderDisplay"];
            this.averageRatingDisplay = _data["averageRatingDisplay"];
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): ProductDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["totalSold"] = this.totalSold;
        data["averageRating"] = this.averageRating;
        if (Array.isArray(this.productOptions)) {
            data["productOptions"] = [];
            for (let item of this.productOptions)
                data["productOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["finalPrice"] = this.finalPrice;
        data["vietnamesePrice"] = this.vietnamesePrice;
        data["forGenderDisplay"] = this.forGenderDisplay;
        data["averageRatingDisplay"] = this.averageRatingDisplay;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IProductDetailDto {
    createdDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    totalSold?: number;
    averageRating?: number;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;
    averageRatingDisplay?: number;
    createdDateDisplay?: string;

    [key: string]: any;
}

class ProductImageDto implements IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.url = _data["url"];
            this.forColor = _data["forColor"] ? ColorDto.fromJS(_data["forColor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["url"] = this.url;
        data["forColor"] = this.forColor ? this.forColor.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;
}

class PaginatedProductBriefDto implements IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PaginatedPaymentDto implements IPaginatedPaymentDto {
    data?: PaymentDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PaymentDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedPaymentDto {
    data?: PaymentDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PaymentDto implements IPaymentDto {
    paymentId?: string;
    status?: PaymentDtoStatus;
    paymentDetails?: string;
    paymentResponse?: string;
    amount?: number;

    [key: string]: any;

    constructor(data?: IPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.status = _data["status"];
            this.paymentDetails = _data["paymentDetails"];
            this.paymentResponse = _data["paymentResponse"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["status"] = this.status;
        data["paymentDetails"] = this.paymentDetails;
        data["paymentResponse"] = this.paymentResponse;
        data["amount"] = this.amount;
        return data;
    }
}

interface IPaymentDto {
    paymentId?: string;
    status?: PaymentDtoStatus;
    paymentDetails?: string;
    paymentResponse?: string;
    amount?: number;

    [key: string]: any;
}

class OrderBriefDto implements IOrderBriefDto {
    createdDate?: Date;
    orderId?: string;
    customerName?: string;
    address?: string;
    paymentMethod?: OrderBriefDtoPaymentMethod;
    phoneNumber?: string;
    email?: string;
    totalAmount?: number;
    note?: string;
    deliveryFee?: number;
    cancelReason?: string;
    status?: OrderBriefDtoStatus;
    latestPayment?: PaymentDto;
    promotion?: PromotionDto;
    completedDate?: Date;
    createdDateDisplay?: string;

    [key: string]: any;

    constructor(data?: IOrderBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.orderId = _data["orderId"];
            this.customerName = _data["customerName"];
            this.address = _data["address"];
            this.paymentMethod = _data["paymentMethod"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.totalAmount = _data["totalAmount"];
            this.note = _data["note"];
            this.deliveryFee = _data["deliveryFee"];
            this.cancelReason = _data["cancelReason"];
            this.status = _data["status"];
            this.latestPayment = _data["latestPayment"] ? PaymentDto.fromJS(_data["latestPayment"]) : <any>undefined;
            this.promotion = _data["promotion"] ? PromotionDto.fromJS(_data["promotion"]) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.createdDateDisplay = _data["createdDateDisplay"];
        }
    }

    static fromJS(data: any): OrderBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["orderId"] = this.orderId;
        data["customerName"] = this.customerName;
        data["address"] = this.address;
        data["paymentMethod"] = this.paymentMethod;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["totalAmount"] = this.totalAmount;
        data["note"] = this.note;
        data["deliveryFee"] = this.deliveryFee;
        data["cancelReason"] = this.cancelReason;
        data["status"] = this.status;
        data["latestPayment"] = this.latestPayment ? this.latestPayment.toJSON() : <any>undefined;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["createdDateDisplay"] = this.createdDateDisplay;
        return data;
    }
}

interface IOrderBriefDto {
    createdDate?: Date;
    orderId?: string;
    customerName?: string;
    address?: string;
    paymentMethod?: OrderBriefDtoPaymentMethod;
    phoneNumber?: string;
    email?: string;
    totalAmount?: number;
    note?: string;
    deliveryFee?: number;
    cancelReason?: string;
    status?: OrderBriefDtoStatus;
    latestPayment?: PaymentDto;
    promotion?: PromotionDto;
    completedDate?: Date;
    createdDateDisplay?: string;

    [key: string]: any;
}

class PaginatedOrderBriefDto implements IPaginatedOrderBriefDto {
    data?: OrderBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedOrderBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedOrderBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedOrderBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedOrderBriefDto {
    data?: OrderBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PaginatedCategoryBriefDto implements IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedCategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedCategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedCategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class CartItemDto implements ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;

    constructor(data?: ICartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
            this.productOption = _data["productOption"] ? ProductOptionDetailDto.fromJS(_data["productOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        data["productOption"] = this.productOption ? this.productOption.toJSON() : <any>undefined;
        return data;
    }
}

interface ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;
}

class DeleteProductImageCommand implements IDeleteProductImageCommand {
    url!: string;

    [key: string]: any;

    constructor(data?: IDeleteProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): DeleteProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["url"] = this.url;
        return data;
    }
}

interface IDeleteProductImageCommand {
    url: string;

    [key: string]: any;
}

class Body implements IBody {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody {
    file: string;

    [key: string]: any;
}

class Body2 implements IBody2 {
    file?: string;

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody2 {
    file?: string;

    [key: string]: any;
}

enum ForGenders {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum ForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum Statuses {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
    WAITING_FOR_REFUND = "WAITING_FOR_REFUND",
}

enum PaymentStatus {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
    WAITING_FOR_REFUND = "WAITING_FOR_REFUND",
}

enum OrderStatus {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    SHIPPING = "SHIPPING",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    RETURNED = "RETURNED",
    REFUNDED = "REFUNDED",
}

enum UpdatePromotionCommandType {
    PERCENTAGE = "PERCENTAGE",
    FIXED_AMOUNT = "FIXED_AMOUNT",
}

enum UpdateProductCommandForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreatePromotionCommandType {
    PERCENTAGE = "PERCENTAGE",
    FIXED_AMOUNT = "FIXED_AMOUNT",
}

enum CreateProductCommandForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum ProductBriefDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreatePaymentResponsePaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum CreateOrderCommandPaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum UpdatePaymentStatusCommandStatus {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
    WAITING_FOR_REFUND = "WAITING_FOR_REFUND",
}

enum UpdateOrderStatusCommandStatus {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    SHIPPING = "SHIPPING",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    RETURNED = "RETURNED",
    REFUNDED = "REFUNDED",
}

enum PromotionDtoType {
    PERCENTAGE = "PERCENTAGE",
    FIXED_AMOUNT = "FIXED_AMOUNT",
}

enum ProductDetailDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum PaymentDtoStatus {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
    WAITING_FOR_REFUND = "WAITING_FOR_REFUND",
}

enum OrderBriefDtoPaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum OrderBriefDtoStatus {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    SHIPPING = "SHIPPING",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    RETURNED = "RETURNED",
    REFUNDED = "REFUNDED",
}

interface FileParameter {
    data: any;
    fileName: string;
}

interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}